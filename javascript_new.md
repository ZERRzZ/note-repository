# **基本语法**

## **语句**

表达式: 为了得到一个值的计算式。

语句: 完成某种任务而进行的操作。

凡是预期为值的地方都能放置表达式。语句以分号结尾，多个语句可在一行展示。

## **三元运算符**

写法: `(条件) ？ 表达式1 : 表达式2`

条件为真时返回表达式 1 中的值，为假则返回表达式 2 的值。是 `if...else...` 的简写形式，但有返回值

## **循环语句**

JS 提供多种循环语句，大体上都是满足某条件时，则不断执行语句。应避免死循环，确立循环终止的条件。

```js
// 当条件为真时，不断执行语句
while (条件) 语句
```

```js
// 先执行一次语句，之后再判断条件是否为真来确定是否执行语句
do 语句
while (条件)
```

```js
// 初始化表达式：循环变量的初始值，只在循环开始前执行一次
// 条件表达式：每轮循环开始时都会判断一次
// 递增表达式：每轮循环最后一个操作，通常递增循环变量
// 可省略任意一个
for (初始化表达式; 条件; 递增表达式) 语句
```

tip: `break` 语句用来跳出代码块或循环、`continue` 语句用来终止本轮循环

```js
for (var i = 0; i < 5; i++) {
  console.log(i)
  if (i === 3) break // 循环只会执行 4 次 0 1 2 3
}
```

```js
var i = 0
while (i < 100) {
  i++
  if (i % 2 === 0) continue
  console.log(i) // 只会打印奇数
}
```

当遇到多层循环时，`break` 和 `continue` 默认只会跳出本层循环，但可以与标签语法配合，来跳出特定的循环。

```js
// 标签语法
label: 语句
```

```js
top: for (var i = 0; i < 3; i++) {
  for (var j = 0; i < 3; j++) {
    if (i === 1 && j === 1) break top
    console.log(i, j) // 0,0 0,1 0,2 1,0
  }
}
```

# **数据类型**

## **简介**

JS 中数据类型有六种：

- number: 数值, 整数和小数
- string: 字符串
- boolean: 布尔值, 表示真伪的两个特殊值 `true` 和 `false`
- undefined: 表示未定义
- null: 表示空值
- object: 对象, 各种值的集合

原始类型: 一般把数值、字符串、布尔值这三种类型合称为原始类型

合成类型: 一般把对象称为合成类型，由多个原始类型的值的组合。

至于 `undefined` 和 `null` 一般看作两个特殊值。

对象又分为三个子类型：

- 狭义的对象（object）
- 数组（array）
- 函数（function）

## **typeof 运算符**

判断一个值到底是什么类型

数值、字符串、布尔值分别返回 `'number'`、`'string'`、`'boolean'`

undefined 返回 `'undefined'`, null 返回 `'object'`, 历史遗留问题

对象返回 `'object'`, 数组返回 `'object'`, typeof 不能区分对象和数组, 函数返回 `'function'`

## **null 和 undefined**

相同: null 与 undefined 都表示没有, 在布尔判定中两者都会自动转为 `false`, 且相等运算符 `==` 会直接报告两者相等

不同: null 表示为一个空对象, 转换为数值时为 `0`, undefined 表示一个未定义的原始值, 转换为数值时为 `NaN`

一般理解为 null 表示空值, undefined 表示未定义

```js
// 变量声明却未赋值时
var i // undefined
```

```js
// 调用函数时参数未提供
function f(x) {
  return x // undefined
}
```

```js
// 对象未赋值的属性
window.sayhello // undefined
```

```js
// 函数没有返回值时，默认返回 undefined
function f() {} // undefined
```

## **数值**

**整数与浮点数**

分类: 整数和浮点数, 但实际上所有数字都以 64 位浮点数形式储存, 即底层根本没有整数, 所有数字都是小数

tip: 浮点数不是精确的值, 所以涉及小数的比较和运算要特别小心

```js
0.1 + 0.2 === 0.3 // false
0.3 / 0.1 // 2.9999999999999996
```

**数值精度**

JS 浮点数的 64 个二进制位:

- 第 1 位: 符号位, `0` 为正数 `1` 为负数
- 第 2 - 12 位: 指数部分, 共 11 位
- 第 13 - 64 位: 小数部分, 共 52 位

一般默认小数部分为 `1.xx...xx`, 及第一位为 1 且不计入, 所以小数部分有 53 位

    公式: `(-1)^符号位 * 1.xx...xx * 2^指数部分`

JS 中可以精确表示的数值范围: `-2 ^ 53 ~ 2 ^ 53`

**数值范围**

指数部分也有一个符号位, 即实际大小 `-2 ^ 10 - 1 ~ 2 ^ 10 - 1`, 再加上一个 `0`, 即 `-1023 ~ 1024` 之间

JS 中可以表示的数值范围: `2 ^ 1024 ~ 2 ^ -1023`, 是开区间

Number 对象的 `MAX_VALUE` 和 `MIN_VALUE` 属性返回可以具体表示的最大最小值

**数值表示法**

数值的表示可以用字面形式直接表示

科学计数法: 使用 `e` 或 `E` 跟一个整数来表示数值的指数部分

**数值的进制**

JS 对用自面形式表示的整数提供了四种进制

- 十进制: 没有前导 0 的数值
- 二进制: 有前缀 `0b` 或 `0B` 的数值
- 十六进制: 有前缀 `0x` 或 `0X` 的数值
- 八进制: 有前缀 `0o` 或 `0O`, 或有前导 0, 且只用到 0-7 的数值(废弃)

```
0xff -> 255
0o377 -> 255
0b11 -> 3
```

**特殊数值**

正负零: `+0` 和 `-0` 区别是 64 位浮点数表示发的符号位不一样

NaN: 表示非数值, 出现在将字符串解析成数字出错, 或一些数学函数的运算结果, 或 `0 / 0` 的场景

Infinity: 表示无穷, 出现在正数太大, 或负数太小, 或 `非0 / 0` 的场景, 有 `Infinity` 与 `-Infinity` 之分

tip: **NaN 不等于包括它本身的任何值; NaN 与包括它本身的任何数运算都为 `NaN`; NaN 在布尔运算时表示为 `false`**

tip: **Infinity 的运算规则同数学上的计算规则**

**全局方法 parseInt**

将字符串转换为整数

规则: 从左到右依次转换直到遇到不能转换的字符为止, 自带 `trim`, 非字符串会转为字符串, 若第一个字符就无法转换则返回 `NaN`

会识别类似进制表示的数值的字符串, 但不能识别科学计数法表示的字符串

`parseInt('')` 返回值为 `NaN`

第二参数: 表示被解析的值的进制 `2 ~ 36` 之间, 默认为 10, 超出则返回 `NaN`

```js
parseInt('1000', 2) // 8
parseInt('1000', 6) // 216
parseInt('1000', 8) // 512
parseInt('1000', 37) // NaN
```

**全局方法 parseFloat**

将字符串转为浮点数

规则: 从左到右依次转换直到遇到不能转换的字符为止, 自带 `trim`, 非字符串会转为字符串, 若第一个字符就无法转换则返回 `NaN`

不会识别类似进制表示的数值的字符串, 但能识别科学计数法表示的字符串

`parseFloat('')` 返回值为 `NaN`

**全局方法 isNaN**

判断一个值是否为 `NaN`

传入其他类型的值会先转为成数值类型, 再判断

tip: 如果想确切的判断**最靠谱的办法是利用 `NaN` 是唯一不等于自身的值的特点**, `value !== value`

## **字符串**

**定义**

零个或多个排在一起的字符，放在单引号或双引号之中

长字符串分成多行可在每一行的尾部使用反斜杠 `\` 也可用链接运算符 `+` 来连接

**转义**

反斜杠 `\` 在字符串内视为转义符

- `\0`: null（`\u0000`）
- `\b`: 后退符（`\u0008`）
- `\f`: 换页符（`\u000C`）
- `\n`: 换行符（`\u000A`）
- `\r`: 回车符（`\u000D`）
- `\t`: 制表符（`\u0009`）
- `\v`: 垂直制表符（`\u000B`）
- `\'`: 单引号（`\u0027`）
- `\"`: 双引号（`\u0022`）
- `\\`: 反斜杠（`\u005C`）

反斜杠的其他特殊用法：

- `\uXXXX`: 四个十六进制数 `0000 - FFFF` 代表一个字符, 对应该字符 Unicode 码点
- `\xHH`: 两个十六进制数 `00 - FF` 代表一个字符, 对应该字符的 Unicode 码点
- `\HHH`: 三个八进制数 `000 - 377` 代表一个字符, 对应该字符的 Unicode 码点

字符串中若在非特殊字符前使用反斜杠, 会自动忽略反斜杠

**字符串与数组**

字符串可以被视为数组

可用方括号运算符 `[]` 来返回某个位置的字符, 也可用 `length` 属性返回字符串的长度, 都是只读不能写

**字符集**

JS 使用 `Unicode` 储存字符, 还允许直接使用 `Unicode 码点` 来表示字符 `\uXXXX`

**Base64 转码**

Base64 是一种编码方式, 可将任意值转成 `0～9、A～Z、a～z、+ 和 /` 这 64 个字符组成的可打印字符

使用它的主要目的不是为了加密, 而是为了不出现特殊字符, 简化程序的处理

- `btoa()`：任意值转为 Base64 编码
- `atob()`：Base64 编码转为原来的值

这两种原生方法不适合非 ASCII 码的字符, 会报错, 要编码非 ASCII 码字符需要插入一个转码环节:

```js
// 转码
function b64Encode(str) {
  return btoa(encodeURIComponent(str))
}
function b64Decode(str) {
  return decodeURIComponent(atob(str))
}

b64Encode('你好') // '...'
b64Decode('...') // '你好'
btoa('你好') // 报错
```

## **对象**

**定义**

对象即一对键值对的集合，是一种无序的复合数据的集合。

用大括号 `{}` 定义一个对象, 键名与键值之间用冒号分隔, 两个键值对之间用逗号分隔

所有的键名都是字符串, 可以不加引号, 对象的键名又称为属性, 它的键值可以是任意数据类型, 当一个属性的值为函数时, 通常称之为方法

**引用类型**

当两个变量名指向同一对象时, 修改其中一个对象的属性会改变另一个, 因为变量是引用类型

当两个变量名指向同一对象时, 取消某一变量对对象的引用, 不会影响到另一个变量

**行首大括号**

当行首是一个大括号时，JS 一律解释为代码块

```js
// 以下一行代码可以是一个对象，foo 属性值为 123
// 也可以是一个代码块，foo 是标签，指向表达式 123
// JS 按第二种表示
{
  foo: 123
}
```

```js
// 如果想解释为对象，可以再套一层圆括号
;({ foo: 123 })
```

**属性操作**

操作对象的属性可以用点运算符 `.` 也可以用方括号运算符 `[]`, 不同点在于 `[]` 里可以放置表达式

删除对象的属性用 `delete` 命令, 他不能删除不能删除的属性, 也不能删除继承而来的属性

```js
var obj = Object.defineProperty({}, 'p', { value: 123 })
delete obj.value // true
delete obj.toString // true，但实际上没删
delete obj.p // false
```

查看一个对象本身的所有属性，可以使用 `Object.keys` 方法

检查对象是否存在某属性可用 `in` 运算符, 但它不能识别属性是否是继承而来的, 这时可用 `hasOwnProperty` 方法来判断一下

```js
'p' in obj // true
'toString' in obj // true
obj.hasOwnProperty('toString') // false
```

属性的遍历, 用 `for...in` 循环来遍历对象的全部属性

- 只遍历可遍历属性，会跳过不可遍历属性(如 toString 等)
- 不仅遍历自身属性，还遍历继承的属性

```js
var obj = { a: 1, b: 2, c: 3 }
for (var i in obj) {
  console.log(i + '\t' + obj[i])
} // a 1 b 2 c 3
```

## **函数**

有三种函数声明方式，分别是 `function` 命令，函数表达式，`Function` 构造函数。

```js
// funciton 命令
function print(s) {
  console.log(s)
}
// 函数表达式
var print = function (s) {
  console.log(s)
}
// 不用匿名函数也可以，但函数名 x 只在该函数体内部生效，代指函数本身
var print = function x() {
  console.log(x)
}
// 不直观
var foo = new Function('a', 'b', 'return a + b')
```

调用函数时要用到圆括号运算符，在圆括号中加入函数的参数。

```js
function add(x, y) {
  return x + y
}
add(1, 2) // 3
```

当遇到函数体内的 `retrun` 语句时，就直接返回 `return` 后面那个表达式的值，然后中止函数，没有 `return` 语句的话就会返回 `undefined`。`return` 语句可以返回函数自己，形成**递归**。

```js
// 计算斐波那契数列
function fib(num) {
  if (num === 0) return 0
  if (num === 1) return 1
  return fib(num - 2) + fib(num - 1)
}
fib(6) // 8
```

函数名同变量名一样，采用 `function` 命令声明函数，也会有提升的现象。

```js
var f = function() { console.log(1) }
funciton f() { console.log(2) }
f() // 1
```

函数的 `length` 属性返回函数预期传入的参数个数，即定义之中的参数个数。

```js
function f(a, b) {}
f.length // 2
```

函数的 `toString()` 方法返回一个字符串，内容是函数的源码。如果是原生函数就返回 `function() {[native code]}`。函数内部的注释也能返回，以此来实现多行字符串。

```js
Math.sqrt.toString() // "function sqrt() { [native code] }"
function f() {
  /*
  这是一个
  多行注释
*/
}

f.toString() // 去掉首位即可
//function f() {/*
//   这是一个
//   多行注释
// */}
```

JS 中有两种作用域，一种是全局作用域，变量在程序中一直存来，所有地方都可以读取；另一种是函数作用域，变量值只存在在函数内部。（ES6 新增块级作用域）

1. 全局变量可以在函数内部读取到，但局部变量在外部无法读取

```js
var v = 1
function f() {
  var u = 2
  console.log(v)
}
f() // 1
u // ReferenceError: v is not defined
```

2. 函数内部定义的变量会在该作用域内覆盖同名的全局变量。

```js
var v = 1
function f() {
  var v = 2
  console.log(v)
}
f() // 2
v // 1
```

3. 函数内部的变量提升和函数声明提升同全局作用域

```js
function f() {
  console.log(a) // undefined
  var a = 1
}
```

4. 函数执行时所在的作用域，是取决于定义时的作用域，而不是调用时所在的作用域。

```js
// 函数 x 定义在全局
var a = 1
var x = function () {
  console.log(a)
}
function f() {
  var a = 2
  x() // 1
}

// 函数 x 定义在局部，闭包
function f() {
  var a = 1
  function x() {
    console.log(a)
  }
  return x
}
var a = 2
f()() // 1
```

有时函数需要依靠外部数据而得到不同的结果，外部数据即参数。参数可以省略，也可以提供多于定义的个数。

```js
function f(a, b) {
  return a
}
f() // undefined
f(1) // 1
f(1, 2) // 1
f(1, 2, 3) // 1
```

函数参数如果是原始类型的值，传递方式是值传递，如果是复合类型的值，则传递方式是地址传递，即传入的是原始值的地址。

```js
var a = 1
var obj = { b: 2 }
var obj2 = { c: 3 }
function f(x, y, z) {
  x = 5
  y.b = 5
  z = { d: 4 }
}
f(a, obj, obj2)
a // 1
obj // { b: 5 }
// 直接替换整个参数不会影响到原始值，因为形参 z 存储的是 obj2 的地址，重新赋值只是导致 z 指向另一个地址
obj2 // { c: 3 }
```

函数中 `argument` 对象包含了函数运行时的所有参数。它是一个类数组但并不是数组，如可以用 `argument[0]` 取第一个参数，而没有 `slice` 方法。用 `length` 属性判断函数调用时到底带了几个参数。

```js
var f = function (a, b) {
  argument[0] = 3
  argument[1] = 2
  console.log(argument.length)
  return a + b
}
f(1, 1) // 5, 2
```

闭包是依靠着链式作用域的结构，使函数外部可以看到函数内部的参数的桥梁。产生条件是两层函数，每次执行外层函数都会形成一个新的闭包，内存消耗量大。

```js
function inc(n) {
  return function () {
    return n++
  }
}
var inc2 = inc(5)
inc2() // 5
inc2() // 6
inc2() // 7
```

立即执行函数 `IIFE`，在定义函数后立马调用函数。

```js
;(function () {
  /* code */
})()
```

## **数组**

按次序排列的一组值即数组。用方括号表示，通过下标来赋值去值，下标从零开始。任何类型的数据都可以放入数组。

```js
var arr = ['a', { a: 1 }, [1, 2, 3]]
arr[0] // 'a'
arr[1] // {a: 1}
arr[2] // [1, 2, 3]
```

数组本质上是一种特殊的对象。它的键名是按次序排列的一组整数。但实际上键名也是字符串（'0', '1', '2'），之所以可以用数值读取，是因为非字符串键名会被转换为字符串。

```js
var arr = [1, 2, 3]
typeof arr // 'object'
Object.keys(arr) // ['0', '1', '2']
arr.0 // SyntaxError 不合法，单独的数值不能作为标识符
arr[0] // 1 方括号是运算符，可接收数值
```

数组 `length` 属性返回数组的成员数量。

- 该属性是一个动态值，等于键名中最大整数加 `1`。
- 数组的数字键不需要连续，`length` 的值始终比最大的那个整数键大 `1`
- `length` 属性可写，如果设置一个小于当前成员个数的值，数组的成员数会自动减少。（可以以此清空数组）
- 设置 `length` 为一个不合法的值会报错（正整数，且最大为 2^32 - 1）

```js
var arr = ['a', 'b']
arr.length // 2
arr[5] = 'f'
arr.length // 6
arr.length = 0
arr // []
```

因为数组本质上是对象，所以可以为数组添加属性，但这不影响 `length` 的属性的值。

```js
var arr = []
arr[-1] = 'a'
arr[Math.pow(2, 32)] = 'b'
arr.length // 0
arr[-1] // 'a' -1 转成了字符串
```

检查某个键名是否存在的运算符 `in`，也适用于数组。但如果数组某个位置是空位时，`in` 运算符返回 `false`。

```js
var arr = []
arr[100] = 'a'
100 in arr // true
'100' in arr // true
1 in arr // false
```

`for...in` 循环也可以遍历数组，但它不仅遍历数字键，还会遍历非数字键。

```js
var a = [1, 2, 3]
a.foo = true
for (var key in a) {
  console.log(key)
}
// 0
// 1
// 2
// foo
```

即如果只想遍历数字键的话可以使用 `for` 循环或 `while` 循环。

```js
var a = [1, 2, 3]

for (var i = 0; i < a.length; i++) {
  console.log(a[i]) // 1 2 3
}

var i = 0
while (i < a.length) {
  console.log(a[i])
  i++
}

var l = a.length
while (l--) {
  console.log(a[l])
}
```

数组的空位即数组某个位置为空。数组的空位不影响 `length` 属性，但影响遍历。

```js
var arr = [1, , 2]
arr[1] // undefined 空位能被读取到，为 undefined，或者说对象未赋值的属性都为 undefined
arr.length // 3
arr.forEach(v => console.log(v)) // 1 2 并不会循环到空位
```

类似数组的对象。一个对象的所有键名都是正整数或零，并且有 `length` 属性。常见的有 `argument` 对象，大多数 `DOM` 元素集，字符串。

# **运算符**

## **算术运算符**

JS 中有 10 个算术运算符，用来完成基本运算。

- 加法运算符：`x + y`
- 减法运算符：`x - y`
- 乘法运算符：`x * y`
- 除法运算符：`x / y`
- 指数运算符：`x ** y`
- 余数运算符：`x % y`
- 自增运算符：`++x` 或 `x++`
- 自减运算符：`--x` 或 `x--`
- 正负运算符：`+x` 和 `-x`

**加法及基本运算符**

从左到右执行，用来求两个数值的和，当遇到布尔值相加或一个加数为布尔值时，会将布尔值自动转换为数值，然后相加。

当遇到字符串时，会将加数转换为字符串，并进行连接。

这种遇到字符串和其他类型时操作不同的情况叫做重载，而其他算术运算符并没有重载，它们的规则是：所有运算子一律转为数值，再进行计算。

```js
1 + false + true // 2

false + 'a' // 'falsea'
'3' + 4 + 5 // '345'
3 + 4 + '5' // '75'

1 - '2' // -1
1 * '2' // 2
1 / '2' // 0.5
```

对象的相加会将对象转成原始类型的值，然后相加。会自动调用 `valueOf` 方法，然后调用 `toString` 方法。

```js
var obj = { p: 1 }
obj + 2 // '[object Object]2'
obj.valueOf() // { p: 1 } 返回对象本身
obj.valueOf().toString() // '[object Object]'
```

**余数运算符**

返回前一个运算子被后一个运算子除所得的余数，运算结果的正负号由第一个运算子的正负号决定。

```js
;-1 % 2 // -1
1 % 2 // 1
```

**自增自减运算符**

是一元运算符，他会将运算子先转换为数值，然后加上 1 或者减去 1，会改变原始变量。

该类运算符放在变量之前，则先进行自增自减操作，在返回变量操作后的值；放在变量之后，则先返回变量操作前的值，再进行自增自减操作。

```js
var x = 1
var y = 1
x++ // 1
++y // 2
```

**正负运算符**

是一元运算符，将任意值转成数值，结果与 `Number` 函数作用一致，只是正负号的不同。

```js
;+true - // 1
  [] + // -0
  {} // NaN
```

**指数运算符**

完成指数运算，前一个运算子是底数，后一个运算子是指数。**指数运算符是右结合**

```js
2 ** (3 ** 2) // 相当于 2 ** (3 ** 2) 512
```

**赋值运算符**

用于给变量赋值。`=` 还可以与其他的运算符结合，形成变体。

```js
x += y // x = x + y
x -= y
x *= y
x /= y
x %= y
x **= y
```

## **比较运算符**

比较运算符用于比较两个值的大小，然后返回一个布尔值。它可以比较各种类型的值。JS 一共提供 8 个比较运算符。

- `>` 大于运算符
- `<` 小于运算符
- `<=` 小于或等于运算符
- `>=` 大于或等于运算符
- `==` 相等运算符
- `===` 严格相等运算符
- `!=` 不相等运算符
- `!==` 严格不相等运算符

非相等运算符的比较，先看两个运算子是否都为字符串，如果是则依次按照 Unicode 码点从左到右比较各字符的大小。如果不是则将两个运算子都转成数值，在比较数值大小。

```js
'cat' > 'Cat' // true，c - 99，C - 67
'大' > '小' // false
5 > '4' // 5 > 4 true
1 >
  NaN[2] > // 运算子是对象，会调用 `valueOf` 方法转换为原始类型值，如果还是对象则再调用 `toString` 方法 // false，与 NaN 的一切比较都为 false
  '11'[2] > // true，[2].valueOf().toString() '2'
  11 // false
```

严格相等/不等运算符 `===`、`!==` 比较两个值是否相等，当数据类型不同时，返回 `false`。严格不等则是将严格相等的结果取反。

```js
1 === '1' // false

// 复合类型的数据比较，比较的是它们是否指向同一个地址
{} === {} // false，两个空对象存放在不同地址
var v1 = {}
var v2 = v1
v1 === v2 // true，v1，v2 指向同一地址

// 两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值
var obj1 = {}
var obj2 = {}
obj1 > obj2 // false
obj2 < obj2 // false
obj1 === obj2 // false
```

相等运算符 `==`，当比较相同数据类型的数据时，与严格相等运算符完全一致。

当比较不同数据类型时，会先将数据进行类型转换，再用严格相等运算符比较。

原始类型的值会转换成数值再进行比较。

```js
'true' == true // NaN === 1, false

// undefined 与 null 相互比较时才为 true
// 与其他类型比较时都为 false
undefined == null // true
```

## **布尔运算符**

**概述**

包括四个运算符: 取反 `!`, 且 `&&`, 或 `||`, 三元 `?:`

**取反运算符**

取反运算符用于将布尔值变为相反值

对于非布尔值, 除了 `undefined` `null` `false` `0` `NaN` `''` 这六个取反后为 `true` 外, 其他都为 `false`

tip: 对一个值进行连续两次取反操作, 等于用 `Boolean` 函数将其转为对应的布尔值

**且运算符**

运算规则: 从左到右计算, 返回第一个布尔值为 `false` 的表达式的**值**, 若都为 `true` 则返回最后一个表达式的**值**

短路: 一旦得出结果, 便不再执行之后的代码

**或运算符**

运算规则: 从左到右计算, 返回第一个布尔值为 `true` 的表达式的**值**, 若都为 `false` 则返回最后一个表达式的**值**

短路: 一旦得出结果, 便不再执行之后的代码

**三元条件运算符**

由问号 `?` 和冒号 `:` 分隔的三个表达式组成

运算规则: 根据第一个表达式的真假来返回第二个表达式的值或第三个表达式的值

## **位运算符**

**概述**

包括七个运算符: `|`, `&`, 非 `~`, 异或 `^`, 左移 `<<`, 右移 `>>`, 头部补零的右移 `>>>`

位运算符只对整数起作用, 若非整数则自动转换为整数, 且是以*带符号的 32 位整数进行运算, 大于等于 2^32 的整数会被舍去*

**或**

运算规则: 逐位比较两个运算子的二进制位, 只要有一个为 1 就返回 1, 否则返回 0

取整: `xxx | 0`

**与**

运算规则: 逐位比较两个运算子, 只要有一个为 0 就返回 0, 否则返回 1

**否**

运算规则: 将每个二进制位都变为相反值 (一个数与自身的取反值相加等于 -1)

取整: `~~xxx`

**异或**

运算规则: 两进制位不同时返回 1, 相同时返回 0

取整: `xxx ^ 0`

互换: `a ^= b; b ^= a; a ^= b`

**左移**

运算规则: 将二进制位向左移动指定位数, 尾部补 0 (乘以 2 的指定次方)

取整: `xxx << 0`

```js
// RGB to HEX
// (1 << 24) 的作用是保证结果是六位数
// 先转成十六进制, 再返回字符串
// 去除字符串最高位, 返回后面六个字符串
const rgb2hex = (r, g, b) =>
  '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).substr(1)
```

**右移**

运算规则: 将二进制位向右移动指定位数, 正数则头部全部补 0, 负数则头部全部补 1 (除以 2 的指定次方)

**头部补零的右移**

运算规则: 将二进制位向右移动指定位数, 头部一律补 0

## **其他**

**void 运算符**

执行一个表达式且返回 undefined, 主要用于在超级链接中插入代码防止网页跳转 `void(表达式)`

**逗号运算符**

对两个表达式求值并返回后一个表达式的值 `a, b`

```js
var value = (console.log('hi!'), true)
// hi!
// value -> true
```

# **进阶语法**

## **类型转换**

强制转换主要使用 `Number()`, `String()`, `Boolean()` 三个函数

**Number()**

字符串如果整体可以被转成数值就转换为相应数值, 但只要有一个字符不行就转为 `NaN`, 空字符串转换为 `0`

布尔值 `true` 转成 `1`, `false` 转成 `0`

`undefined` 转成 `NaN`, `null` 转成 `0`

对象返回 `NaN`, 除了单个数值的数组 (先调用 `obj.valueOf`, 不是原始值则继续调用 `obj.toString`, 之后不再化解直接转换)

**String()**

数值, 布尔值, undefined, null 都转为相应的字符串

对象返回一个类型字符串("[object Object]"), 数组则返回该数组的字符串形式

**Boolean()**

除 `undefined`, `null`, `0`, `NaN`, `''` 这五个值转换为 `false`, 其他值都为 `true`

布尔对象也为 `true` (new Boolean(false) == true), 所有对象都是 `true` 是为了保证性能

**自动转换**

当预期为布尔值的地方如 `if`, `?:`, `!!` 等会自动调用 `Boolean()` 方法转换成布尔值

当预期为字符串的地方, 一般是字符串的加法运算时, 会自动调用 `String()` 方法转换成字符串

当预期为数值的地方, 除了上面 `+` 运算符可能会自动转成字符串外, 其他算术运算符都会把运算子自动转成数值, 包括正负运算符
